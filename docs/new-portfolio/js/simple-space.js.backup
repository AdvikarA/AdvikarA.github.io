import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { gsap } from 'gsap';

// Canvas
const canvas = document.querySelector('canvas.webgl');

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000814);

// Loading screen handling
setTimeout(() => {
    document.querySelector('.loading-screen').style.display = 'none';
    document.querySelector('.info-panel').classList.add('visible');
    
    // Add close button to info panel
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Ã—';
    closeButton.className = 'close-panel';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '10px';
    closeButton.style.right = '10px';
    closeButton.style.background = 'rgba(93, 156, 236, 0.3)';
    closeButton.style.color = '#ffffff';
    closeButton.style.border = 'none';
    closeButton.style.borderRadius = '50%';
    closeButton.style.width = '30px';
    closeButton.style.height = '30px';
    closeButton.style.fontSize = '20px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.display = 'flex';
    closeButton.style.alignItems = 'center';
    closeButton.style.justifyContent = 'center';
    closeButton.style.lineHeight = '1';
    
    document.querySelector('.info-panel').appendChild(closeButton);
    
    closeButton.addEventListener('click', () => {
        document.querySelector('.info-panel').classList.remove('visible');
    });
}, 1000);

// Create planets
const planets = {};

// Function to create planet labels
function createPlanetLabel(planet, name) {
    // Create canvas for the label
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 128;
    const context = canvas.getContext('2d');
    
    // Set background to transparent
    context.fillStyle = 'rgba(0, 0, 0, 0)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw text
    context.font = 'bold 40px Orbitron, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // Create gradient for text
    const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
    gradient.addColorStop(0, '#5d9cec');
    gradient.addColorStop(0.5, '#ffffff');
    gradient.addColorStop(1, '#5d9cec');
    context.fillStyle = gradient;
    
    // Add glow effect
    context.shadowColor = '#5d9cec';
    context.shadowBlur = 15;
    
    // Write the text
    context.fillText(name.toUpperCase(), canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false
    });
    
    // Create sprite
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(10, 5, 1);
    sprite.position.copy(planet.position);
    sprite.position.y += 8; // Position above planet
    
    // Add to scene
    scene.add(sprite);
    
    return sprite;
}

// Home planet
const homePlanetGeometry = new THREE.SphereGeometry(5, 32, 32);
const homePlanetMaterial = new THREE.MeshStandardMaterial({
    color: 0x5d9cec,
    roughness: 0.7,
    metalness: 0.2
});
const homePlanet = new THREE.Mesh(homePlanetGeometry, homePlanetMaterial);
homePlanet.position.set(0, 0, 0);
scene.add(homePlanet);
planets['home'] = homePlanet;
homePlanet.userData.isVisitable = true;

// Add label to home planet
const homeLabel = createPlanetLabel(homePlanet, 'Home');

// Projects hub planet
const projectsHubGeometry = new THREE.SphereGeometry(5, 32, 32);
const projectsHubMaterial = new THREE.MeshStandardMaterial({
    color: 0x8c7ae6,
    roughness: 0.7,
    metalness: 0.2
});
const projectsPlanet = new THREE.Mesh(projectsHubGeometry, projectsHubMaterial);
projectsPlanet.position.set(30, 5, -20);
scene.add(projectsPlanet);
planets['projects'] = projectsPlanet;
projectsPlanet.userData.isVisitable = true;

// Add label to projects hub planet
const projectsLabel = createPlanetLabel(projectsPlanet, 'Projects Hub');

// Create individual project planets - much smaller
const projectPlanets = {};

// Calculate positions in orbit around the projects hub
const projectsPlanetPos = projectsPlanet.position;
const orbitRadius = 12; // Smaller orbit radius
const projectData = [
    { name: 'ampleharvest', category: 'ai', index: 0 },
    { name: 'qaoa', category: 'ai', index: 1 },
    { name: 'facies', category: 'ai', index: 2 },
    { name: 'boulder', category: 'ai', index: 3 },
    { name: 'momentum', category: 'game', index: 4 },
    { name: 'burger', category: 'game', index: 5 },
    { name: 'galaxsea', category: 'game', index: 6 },
    { name: 'skyfarer', category: 'game', index: 7 }
];

// Create each project planet
projectData.forEach(project => {
    // Calculate position in orbit
    const angle = (project.index / projectData.length) * Math.PI * 2;
    const x = projectsPlanetPos.x + Math.cos(angle) * orbitRadius;
    const y = projectsPlanetPos.y + (Math.random() * 2 - 1) * 2; // Slight vertical variation
    const z = projectsPlanetPos.z + Math.sin(angle) * orbitRadius;
    
    // Create planet - much smaller size
    const size = 0.6 + Math.random() * 0.4; // Very small planets
    const color = project.category === 'ai' ? 0x5d9cec : 0xec5d9c; // Different colors for AI vs Game projects
    const geometry = new THREE.SphereGeometry(size, 16, 16); // Lower polygon count for small planets
    const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.2,
        roughness: 0.6,
        metalness: 0.3
    });
    
    const projectPlanet = new THREE.Mesh(geometry, material);
    projectPlanet.position.set(x, y, z);
    scene.add(projectPlanet);
    
    // Store in projectPlanets object but NOT in the main planets object
    // This way they won't be considered for navigation at all
    projectPlanets[project.name] = projectPlanet;
});

// Mark the main projects planet as visitable
projectsPlanet.userData.isVisitable = true;

// Skills planet
const skillsPlanetGeometry = new THREE.SphereGeometry(4, 32, 32);
const skillsPlanetMaterial = new THREE.MeshStandardMaterial({
    color: 0x4cd137,
    roughness: 0.7,
    metalness: 0.2
});
const skillsPlanet = new THREE.Mesh(skillsPlanetGeometry, skillsPlanetMaterial);
skillsPlanet.position.set(-25, -8, -35);
scene.add(skillsPlanet);
planets['skills'] = skillsPlanet;
skillsPlanet.userData.isVisitable = true;

// Add label to skills planet
const skillsLabel = createPlanetLabel(skillsPlanet, 'Skills');

// About planet
const aboutPlanetGeometry = new THREE.SphereGeometry(6, 32, 32);
const aboutPlanetMaterial = new THREE.MeshStandardMaterial({
    color: 0xe84118,
    roughness: 0.7,
    metalness: 0.2
});
const aboutPlanet = new THREE.Mesh(aboutPlanetGeometry, aboutPlanetMaterial);
aboutPlanet.position.set(40, -10, 25);
scene.add(aboutPlanet);
planets['about'] = aboutPlanet;
aboutPlanet.userData.isVisitable = true;

// Add label to about planet
const aboutLabel = createPlanetLabel(aboutPlanet, 'About');

// Contact planet
const contactPlanetGeometry = new THREE.SphereGeometry(3.5, 32, 32);
const contactPlanetMaterial = new THREE.MeshStandardMaterial({
    color: 0xfbc531,
    roughness: 0.7,
    metalness: 0.2
});
const contactPlanet = new THREE.Mesh(contactPlanetGeometry, contactPlanetMaterial);
contactPlanet.position.set(-35, 15, 40);
scene.add(contactPlanet);
planets['contact'] = contactPlanet;
contactPlanet.userData.isVisitable = true;

// Add label to contact planet
const contactLabel = createPlanetLabel(contactPlanet, 'Contact');

// Create a better-looking spaceship
const spaceship = new THREE.Group();

// Main body - sleeker fuselage
const bodyGeometry = new THREE.CylinderGeometry(0.6, 1, 4, 8);
const bodyMaterial = new THREE.MeshStandardMaterial({
    color: 0xd8e2f3,  // Lighter blue-silver
    metalness: 0.9,
    roughness: 0.2,
    emissive: 0x3d5cac,
    emissiveIntensity: 0.2
});
const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
// Rotate to point forward visually, but backward in terms of movement
body.rotation.x = Math.PI / 2;
spaceship.add(body);

// Add cockpit
const cockpitGeometry = new THREE.SphereGeometry(0.7, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
const cockpitMaterial = new THREE.MeshStandardMaterial({
    color: 0x5d9cec,
    metalness: 0.1,
    roughness: 0.2,
    transparent: true,
    opacity: 0.9,
    emissive: 0x5d9cec,
    emissiveIntensity: 0.3
});
const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
// Position cockpit at the visual front
cockpit.position.set(0, 0.4, -1.5);
cockpit.rotation.x = Math.PI;
spaceship.add(cockpit);

// Add wings
const wingGeometry = new THREE.BoxGeometry(5, 0.2, 1.5);
const wingMaterial = new THREE.MeshStandardMaterial({
    color: 0x5d9cec,
    metalness: 0.7,
    roughness: 0.3
});
const wings = new THREE.Mesh(wingGeometry, wingMaterial);
wings.position.y = 0.1;
spaceship.add(wings);

// Add wing tips
const wingTipGeometry = new THREE.ConeGeometry(0.4, 1, 4);
const wingTipMaterial = new THREE.MeshStandardMaterial({
    color: 0xe74c3c,
    emissive: 0xe74c3c,
    emissiveIntensity: 0.5
});

const leftWingTip = new THREE.Mesh(wingTipGeometry, wingTipMaterial);
leftWingTip.position.set(-2.5, 0.1, -0.5);
leftWingTip.rotation.z = -Math.PI / 2;
spaceship.add(leftWingTip);

const rightWingTip = new THREE.Mesh(wingTipGeometry, wingTipMaterial);
rightWingTip.position.set(2.5, 0.1, -0.5);
rightWingTip.rotation.z = Math.PI / 2;
spaceship.add(rightWingTip);

// Add engine glow at the back of the ship
const engineGlowGeometry = new THREE.SphereGeometry(0.6, 16, 16);
const engineGlowMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.7
});
const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
// Position at positive z (visual back of ship)
engineGlow.position.z = 2;
spaceship.add(engineGlow);

// Create thruster effect
const thruster = engineGlow.clone();
thruster.scale.set(1.5, 1.5, 3);
thruster.position.z = 2.5; // Positive z for visual back
thruster.material = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.5
});
spaceship.add(thruster);
thruster.visible = false;

// Add thruster light
const thrusterLight = new THREE.PointLight(0x00ffff, 0, 10);
thrusterLight.position.z = 3; // Positive z for visual back
spaceship.add(thrusterLight);

// Add collision sphere for the spaceship (invisible)
spaceship.userData.collisionRadius = 3; // Collision radius for the spaceship

// Position the spaceship (much smaller scale)
spaceship.scale.set(0.8, 0.8, 0.8);
spaceship.position.set(0, 0, 15);
// Rotate 180 degrees to face backward (but visually forward)
spaceship.rotation.y = Math.PI;
scene.add(spaceship);

// Update collision radius to match smaller ship
spaceship.userData.collisionRadius = 1.2;

// Add a pulsing animation to the engine glow for better visibility
gsap.to(engineGlow.scale, {
    x: 1.8,
    y: 1.8,
    z: 1.8,
    duration: 0.5,
    repeat: -1,
    yoyo: true,
    ease: 'power1.inOut'
});

// Create particle system for thruster
const particleCount = 200;
const particleGeometry = new THREE.BufferGeometry();
const particlePositions = new Float32Array(particleCount * 3);
const particleSizes = new Float32Array(particleCount);

// Initialize particles at random positions at the visual back of ship
for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;
    particlePositions[i3] = (Math.random() - 0.5) * 0.5;
    particlePositions[i3 + 1] = (Math.random() - 0.5) * 0.5;
    particlePositions[i3 + 2] = 2 + Math.random() * 3; // Positive z is visual back of ship
    particleSizes[i] = Math.random() * 0.5 + 0.1;
}

particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

// Create particle material with custom shader
const particleMaterial = new THREE.PointsMaterial({
    color: 0x00ffff,
    size: 0.5,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending,
    sizeAttenuation: true
});

const thrusterParticles = new THREE.Points(particleGeometry, particleMaterial);
thrusterParticles.visible = false;
spaceship.add(thrusterParticles);

// Create stars
const starsGeometry = new THREE.BufferGeometry();
const starsCount = 1000;
const starsPositions = new Float32Array(starsCount * 3);

for (let i = 0; i < starsCount; i++) {
    const i3 = i * 3;
    starsPositions[i3] = (Math.random() - 0.5) * 300;
    starsPositions[i3 + 1] = (Math.random() - 0.5) * 300;
    starsPositions[i3 + 2] = (Math.random() - 0.5) * 300;
}

starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));

const starsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 1,
    sizeAttenuation: true
});

const stars = new THREE.Points(starsGeometry, starsMaterial);
scene.add(stars);

// Lights - add plenty of light to make sure everything is visible
const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Increased ambient light
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // Increased intensity
directionalLight.position.set(50, 50, 50);
scene.add(directionalLight);

// Add a light that follows the camera to illuminate the spaceship
const spaceshipLight = new THREE.PointLight(0xffffff, 1, 30);
spaceshipLight.position.set(0, 5, 20);
scene.add(spaceshipLight);

// Add point lights at each planet with increased intensity
const homeLightColor = new THREE.Color(0x5d9cec);
const homePointLight = new THREE.PointLight(homeLightColor, 3, 50);
homePointLight.position.copy(homePlanet.position);
scene.add(homePointLight);

const projectsLightColor = new THREE.Color(0x8c7ae6);
const projectsPointLight = new THREE.PointLight(projectsLightColor, 3, 50);
projectsPointLight.position.copy(projectsPlanet.position);
scene.add(projectsPointLight);

const skillsLightColor = new THREE.Color(0x4cd137);
const skillsPointLight = new THREE.PointLight(skillsLightColor, 3, 50);
skillsPointLight.position.copy(skillsPlanet.position);
scene.add(skillsPointLight);

const aboutLightColor = new THREE.Color(0xe84118);
const aboutPointLight = new THREE.PointLight(aboutLightColor, 3, 50);
aboutPointLight.position.copy(aboutPlanet.position);
scene.add(aboutPointLight);

const contactLightColor = new THREE.Color(0xfbc531);
const contactPointLight = new THREE.PointLight(contactLightColor, 3, 50);
contactPointLight.position.copy(contactPlanet.position);
scene.add(contactPointLight);

// Sizes
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
};

// Camera
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000);
camera.position.set(0, 5, 20);
scene.add(camera);

// Controls
const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enableZoom = true;
controls.enablePan = false;
controls.maxDistance = 100;
controls.minDistance = 5;

// Renderer
const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true
});
renderer.setSize(sizes.width, sizes.height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// Navigation
let currentPlanet = 'home';
let isNavigating = false;
let nearbyPlanet = null;
let visitPopupVisible = false;
let inPlanetView = false; // Flag to track if we're in planet view mode

// Create a popup for planet visits
const visitPopup = document.createElement('div');
visitPopup.className = 'visit-popup';
visitPopup.innerHTML = 'Press SHIFT to visit';
visitPopup.style.position = 'absolute';
visitPopup.style.bottom = '20%';
visitPopup.style.left = '50%';
visitPopup.style.transform = 'translateX(-50%)';
visitPopup.style.backgroundColor = 'rgba(0, 10, 30, 0.7)';
visitPopup.style.color = '#ffffff';
visitPopup.style.padding = '10px 20px';
visitPopup.style.borderRadius = '5px';
visitPopup.style.fontFamily = "'Orbitron', sans-serif";
visitPopup.style.fontSize = '16px';
visitPopup.style.border = '1px solid rgba(93, 156, 236, 0.5)';
visitPopup.style.boxShadow = '0 0 15px rgba(93, 156, 236, 0.3)';
visitPopup.style.display = 'none';
visitPopup.style.zIndex = '100';
document.body.appendChild(visitPopup);

// Create exit button - now positioned at the bottom of the popup
const exitButton = document.createElement('div');
exitButton.className = 'exit-button';
exitButton.innerHTML = 'CLOSE & EXIT PLANET';
exitButton.style.position = 'fixed';
exitButton.style.bottom = '30px';
exitButton.style.left = '50%';
exitButton.style.transform = 'translateX(-50%)';
exitButton.style.backgroundColor = 'rgba(255, 50, 50, 0.7)';
exitButton.style.color = '#ffffff';
exitButton.style.padding = '15px 30px';
exitButton.style.borderRadius = '5px';
exitButton.style.fontFamily = "'Orbitron', sans-serif";
exitButton.style.fontSize = '16px';
exitButton.style.border = '1px solid rgba(255, 100, 100, 0.5)';
exitButton.style.boxShadow = '0 0 15px rgba(255, 50, 50, 0.3)';
exitButton.style.cursor = 'pointer';
exitButton.style.display = 'none';
exitButton.style.zIndex = '1001';
exitButton.style.marginTop = '30px';
document.body.appendChild(exitButton);

// Add click event to exit button
exitButton.addEventListener('click', exitPlanetView);

// Create planet info popup container - full screen version
const planetInfoPopup = document.createElement('div');
planetInfoPopup.className = 'planet-info-popup';
planetInfoPopup.style.position = 'fixed';
planetInfoPopup.style.top = '0';
planetInfoPopup.style.left = '0';
planetInfoPopup.style.width = '100%';
planetInfoPopup.style.height = '100%';
planetInfoPopup.style.backgroundColor = 'rgba(0, 10, 30, 0.92)';
planetInfoPopup.style.color = '#ffffff';
planetInfoPopup.style.padding = '40px';
planetInfoPopup.style.fontFamily = "'Orbitron', sans-serif";
planetInfoPopup.style.fontSize = '16px';
planetInfoPopup.style.border = '2px solid rgba(93, 156, 236, 0.8)';
planetInfoPopup.style.boxSizing = 'border-box';
planetInfoPopup.style.overflowY = 'auto';
planetInfoPopup.style.display = 'none';
planetInfoPopup.style.zIndex = '1000';
planetInfoPopup.style.backdropFilter = 'blur(5px)';
document.body.appendChild(planetInfoPopup);

// Function to show planet info popup
function showPlanetInfoPopup(planetName) {
    let popupContent = '';
    
    // If trying to visit a non-visitable planet, don't show anything
    const planet = planets[planetName];
    if (planet && planet.userData && planet.userData.isVisitable === false) {
        return;
    }
    
    switch(planetName) {
        case 'home':
            popupContent = `
                <div class="popup-content">
                    <h1>Welcome to My Space</h1>
                    <p>Hi, I'm <strong>Advikar</strong>, an undergraduate attending <strong>Harvard University</strong>. 
                    Currently, I'm interested in Software and AI/Machine Learning.</p>
                    <p>I like pens, rocks, stars, and deer (among other things). Navigate through my universe using the ship controls or select a destination from the navigation console.</p>
                    <div class="social-links">
                        <a href="https://github.com/AdvikarA" title="GitHub"><i class="fab fa-github"></i> GitHub</a>
                        <a href="https://www.linkedin.com/in/advikar-ananthkumar-79b568311/" title="LinkedIn"><i class="fab fa-linkedin"></i> LinkedIn</a>
                        <a href="https://open.spotify.com/user/cyanair24" title="Spotify"><i class="fab fa-spotify"></i> Spotify</a>
                        <a href="https://discord.com/users/cyanair24" title="Discord"><i class="fab fa-discord"></i> Discord</a>
                    </div>
                </div>
            `;
            break;
        case 'projects':
            // For projects, show all projects together like the original site
            popupContent = `
                <div class="popup-content">
                    <h1>Project Nebula</h1>
                    <p>Explore my projects across different domains. The small planets orbiting this hub represent individual projects.</p>
                    
                    <div class="project-categories">
                        <div class="project-category">
                            <h2>AI/Machine Learning</h2>
                            <div class="project-grid">
                                <div class="project-item">
                                    <h3>AmpleHarvest Webscraper</h3>
                                    <p>An LLM-powered contact verification system that helps food pantries maintain accurate contact information.</p>
                                    <ul>
                                        <li>Automated web scraping to verify contact information</li>
                                        <li>LLM integration for intelligent data processing</li>
                                        <li>Improved efficiency in maintaining pantry database</li>
                                    </ul>
                                </div>
                                
                                <div class="project-item">
                                    <h3>Quantum Approximate Optimization Algorithm</h3>
                                    <p>Research and implementation of quantum algorithms for optimization problems.</p>
                                    <ul>
                                        <li>Quantum circuit design for optimization</li>
                                        <li>Performance comparison with classical algorithms</li>
                                        <li>Application to real-world optimization problems</li>
                                    </ul>
                                </div>
                                
                                <div class="project-item">
                                    <h3>Geographic Facies Predictor</h3>
                                    <p>Machine learning model to predict geological facies from well log data.</p>
                                    <ul>
                                        <li>Predictive modeling of subsurface geology</li>
                                        <li>Data processing of well log information</li>
                                        <li>Visualization of geological predictions</li>
                                    </ul>
                                </div>
                                
                                <div class="project-item">
                                    <h3>Planetary Boulder Detection</h3>
                                    <p>Computer vision system to identify and analyze boulders in planetary imagery.</p>
                                    <ul>
                                        <li>Automated detection of boulders in satellite imagery</li>
                                        <li>Size and distribution analysis</li>
                                        <li>Terrain characterization for planetary exploration</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div class="project-category">
                            <h2>Game Development</h2>
                            <div class="project-grid">
                                <div class="project-item">
                                    <h3>Momentum</h3>
                                    <p>A 2D platformer game based on friction mechanics and momentum physics.</p>
                                    <ul>
                                        <li>Unique friction-based movement system</li>
                                        <li>Physics-driven gameplay mechanics</li>
                                        <li>Challenging level design</li>
                                    </ul>
                                </div>
                                
                                <div class="project-item">
                                    <h3>Burger Brawl</h3>
                                    <p>A 2D action/fighter game created in just 24 hours for a game jam.</p>
                                    <ul>
                                        <li>Fast-paced combat mechanics</li>
                                        <li>Unique food-themed characters</li>
                                        <li>Rapid development under time constraints</li>
                                    </ul>
                                </div>
                                
                                <div class="project-item">
                                    <h3>Galaxsea</h3>
                                    <p>A modern twist on the iconic arcade shooter Galaga with underwater themes.</p>
                                    <ul>
                                        <li>Classic arcade gameplay with modern elements</li>
                                        <li>Underwater visual aesthetic</li>
                                        <li>Progressive difficulty system</li>
                                    </ul>
                                </div>
                                
                                <div class="project-item">
                                    <h3>Skyfarer</h3>
                                    <p>A dialogue-based VR flying experience that combines storytelling with flight simulation.</p>
                                    <ul>
                                        <li>Immersive VR flight mechanics</li>
                                        <li>Branching dialogue system</li>
                                        <li>Narrative-driven gameplay</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            break;
        case 'skills':
            popupContent = `
                <div class="popup-content">
                    <h1>Skill Constellation</h1>
                    <p>Technologies and skills I've been working with:</p>
                    <div class="skills-grid">
                        <div class="skill-category">
                            <h2>Programming</h2>
                            <ul>
                                <li>Python</li>
                                <li>JavaScript</li>
                                <li>C#</li>
                                <li>Data Structures & Algorithms</li>
                            </ul>
                        </div>
                        <div class="skill-category">
                            <h2>AI/ML</h2>
                            <ul>
                                <li>Machine Learning</li>
                                <li>Quantum Computing</li>
                                <li>Computer Vision</li>
                                <li>LLMs</li>
                            </ul>
                        </div>
                        <div class="skill-category">
                            <h2>Currently Learning</h2>
                            <ul>
                                <li>Ventures/Startups</li>
                                <li>Quantum Computing</li>
                                <li>Machine Learning Proficiency</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            break;
        case 'about':
            popupContent = `
                <div class="popup-content">
                    <h1>About Orbit</h1>
                    <p>I'm an undergraduate at <strong>Harvard University</strong> with interests in Software and AI/Machine Learning.</p>
                    <h2>Recent Updates</h2>
                    <ul>
                        <li>Completed Harvard Financial Analysts Club Quant Learning Track -- Finished 4th / ~20 teams in final trading game</li>
                        <li>Completed Harvard Financial Analysts Club Traditional Track -- Pitched a long position on a medium/long term horizon for APH</li>
                        <li>Selected as Harvard Undergrad Science Olympiad Freshman Rep + Wrote 2 tests</li>
                        <li>Contributed to Ample Harvest LLM Webscraper</li>
                        <li>Contributed to QAOA Quantum ML algorithm</li>
                        <li>1st in Harvard Ventures Beginner Start Up Pitch with indoor navigation app AIM</li>
                    </ul>
                </div>
            `;
            break;
        case 'contact':
            popupContent = `
                <div class="popup-content">
                    <h1>Contact Station</h1>
                    <p>Feel free to reach out through any of these channels:</p>
                    <div class="contact-links">
                        <a href="https://github.com/AdvikarA" class="contact-link"><i class="fab fa-github"></i> GitHub: AdvikarA</a>
                        <a href="https://www.linkedin.com/in/advikar-ananthkumar-79b568311/" class="contact-link"><i class="fab fa-linkedin"></i> LinkedIn: Advikar Ananthkumar</a>
                        <a href="https://discord.com/users/cyanair24" class="contact-link"><i class="fab fa-discord"></i> Discord: cyanair24</a>
                    </div>
                </div>
            `;
            break;
        // For individual project planets, redirect to the projects hub
        case 'ampleharvest':
        case 'qaoa':
        case 'facies':
        case 'boulder':
        case 'momentum':
        case 'burger':
        case 'galaxsea':
        case 'skyfarer':
            // Redirect to projects hub
            navigateToPlanet('projects');
            return;
        default:
            popupContent = `<h1>${planetName.charAt(0).toUpperCase() + planetName.slice(1)}</h1>`;
    }
    
    // Add some CSS for the popup content
    popupContent += `
        <style>
            .popup-content {
                max-width: 1000px;
                margin: 0 auto;
                padding: 20px;
            }
            .popup-content h1 {
                font-size: 36px;
                margin-bottom: 20px;
                color: #5d9cec;
                text-shadow: 0 0 10px rgba(93, 156, 236, 0.5);
            }
            .popup-content h2 {
                font-size: 24px;
                margin-top: 30px;
                margin-bottom: 15px;
                color: #5d9cec;
            }
            .popup-content h3 {
                font-size: 20px;
                margin-top: 20px;
                color: #ffffff;
            }
            .popup-content p {
                font-size: 16px;
                line-height: 1.6;
                margin-bottom: 15px;
            }
            .popup-content ul {
                margin-left: 20px;
                margin-bottom: 20px;
            }
            .popup-content li {
                margin-bottom: 8px;
                line-height: 1.4;
            }
            .social-links, .contact-links {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                margin-top: 30px;
            }
            .social-links a, .contact-links a {
                color: #5d9cec;
                text-decoration: none;
                padding: 10px 15px;
                border-radius: 5px;
                background-color: rgba(93, 156, 236, 0.1);
                border: 1px solid rgba(93, 156, 236, 0.3);
                transition: all 0.3s ease;
            }
            .social-links a:hover, .contact-links a:hover {
                background-color: rgba(93, 156, 236, 0.3);
                transform: translateY(-2px);
            }
            .project-categories {
                margin-top: 30px;
            }
            .project-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
                gap: 30px;
                margin-top: 20px;
            }
            .project-item {
                background-color: rgba(93, 156, 236, 0.1);
                border: 1px solid rgba(93, 156, 236, 0.3);
                border-radius: 10px;
                padding: 20px;
                transition: all 0.3s ease;
            }
            .project-item:hover {
                background-color: rgba(93, 156, 236, 0.2);
                transform: translateY(-5px);
                box-shadow: 0 5px 15px rgba(93, 156, 236, 0.3);
            }
            .skills-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 30px;
                margin-top: 30px;
            }
            .skill-category {
                background-color: rgba(93, 156, 236, 0.1);
                border: 1px solid rgba(93, 156, 236, 0.3);
                border-radius: 10px;
                padding: 20px;
            }
            @media (max-width: 768px) {
                .project-grid {
                    grid-template-columns: 1fr;
                }
                .skills-grid {
                    grid-template-columns: 1fr;
                }
            }
        </style>
    `;
    
    planetInfoPopup.innerHTML = popupContent;
    planetInfoPopup.style.display = 'block';
}

// Function to exit planet view and return to travel mode
function exitPlanetView() {
    if (isNavigating) return;
    
    isNavigating = true;
    inPlanetView = false;
    
    // Hide exit button and planet info popup
    exitButton.style.display = 'none';
    planetInfoPopup.style.display = 'none';
    
    // Show UI elements again
    const uiContainer = document.querySelector('.ui-container');
    if (uiContainer) {
        uiContainer.style.opacity = '1';
        uiContainer.style.pointerEvents = 'auto';
    }
    
    // Calculate camera position based on spaceship orientation
    const cameraOffset = new THREE.Vector3(0, 5, 15);
    cameraOffset.applyQuaternion(spaceship.quaternion);
    const targetPosition = new THREE.Vector3().copy(spaceship.position).add(cameraOffset);
    
    // Set controls target to spaceship immediately to prevent view jumping
    controls.target.copy(spaceship.position);
    
    // Animate camera movement
    gsap.to(camera.position, {
        x: targetPosition.x,
        y: targetPosition.y,
        z: targetPosition.z,
        duration: 1.5,
        ease: 'power2.inOut',
        onUpdate: () => {
            // Keep controls target on spaceship during animation
            controls.target.copy(spaceship.position);
        },
        onComplete: () => {
            isNavigating = false;
        }
    });
}

function navigateToPlanet(planetName) {
    if (isNavigating || !planets[planetName]) return;
    
    // Check if the planet is visitable
    const targetPlanet = planets[planetName];
    if (targetPlanet.userData && targetPlanet.userData.isVisitable === false) {
        // If trying to navigate to a non-visitable planet, redirect to the projects hub
        planetName = 'projects';
    }
    
    isNavigating = true;
    currentPlanet = planetName;
    inPlanetView = true; // Set planet view mode
    
    // Reset all controls to prevent movement during planet view
    shipControls.up = false;
    shipControls.down = false;
    shipControls.left = false;
    shipControls.right = false;
    shipControls.thrust = false;
    
    // Update UI
    document.querySelectorAll('.planet-selector li').forEach(item => {
        item.classList.remove('active');
    });
    
    const planetSelector = document.querySelector(`.planet-selector li[data-planet="${planetName}"]`);
    if (planetSelector) {
        planetSelector.classList.add('active');
    }
    
    // Hide the info panel since we're using full-screen popups
    const infoPanel = document.querySelector('.info-panel');
    if (infoPanel) {
        infoPanel.classList.remove('visible');
    }
    
    // Hide UI elements when in planet view
    const uiContainer = document.querySelector('.ui-container');
    if (uiContainer) {
        uiContainer.style.opacity = '0';
        uiContainer.style.pointerEvents = 'none';
    }
    
    const planet = planets[planetName];
    
    // Get current spaceship direction
    const shipDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(spaceship.quaternion).normalize();
    
    // Calculate vector from spaceship to planet
    const toPlanet = new THREE.Vector3().subVectors(planet.position, spaceship.position).normalize();
    
    // Calculate dot product to see if ship is already facing the planet
    const dotProduct = shipDirection.dot(toPlanet);
    
    // Keep the spaceship where it is
    const spaceshipTargetPosition = new THREE.Vector3().copy(spaceship.position);
    
    // Make spaceship look directly at the planet
    const lookAt = new THREE.Vector3().copy(planet.position);
    
    // Create a quaternion for the target rotation
    const targetQuaternion = new THREE.Quaternion();
    const upVector = new THREE.Vector3(0, 1, 0);
    const matrix = new THREE.Matrix4().lookAt(spaceship.position, lookAt, upVector);
    targetQuaternion.setFromRotationMatrix(matrix);
    
    // Animate spaceship rotation to face the planet
    gsap.to(spaceship.quaternion, {
        x: targetQuaternion.x,
        y: targetQuaternion.y,
        z: targetQuaternion.z,
        w: targetQuaternion.w,
        duration: 1,
        ease: 'power2.inOut'
    });
    
    // Calculate the ideal camera position - in front of the spaceship facing the planet
    const targetPosition = new THREE.Vector3();
    
    // If we're already close to the planet, position camera between ship and planet
    if (spaceship.position.distanceTo(planet.position) < 20 * 2) {
        // Position camera closer to the planet for a better view
        const closerDistance = planet.geometry.parameters.radius * 2 + 5; // Much closer to the planet
        targetPosition.copy(planet.position)
            .sub(spaceship.position)
            .normalize()
            .multiplyScalar(closerDistance)
            .add(planet.position);
    } else {
        // Position camera at closer viewing distance from planet
        const closerDistance = planet.geometry.parameters.radius * 2 + 5; // Much closer to the planet
        targetPosition.copy(planet.position)
            .sub(spaceship.position)
            .normalize()
            .multiplyScalar(closerDistance)
            .add(planet.position);
    }
    
    // Set controls.target to planet position immediately to prevent view jumping
    controls.target.copy(planet.position);
    
    // Animate camera movement
    gsap.to(camera.position, {
        x: targetPosition.x,
        y: targetPosition.y,
        z: targetPosition.z,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
            // Keep controls target on planet during animation
            controls.target.copy(planet.position);
        },
        onComplete: () => {
            isNavigating = false;
            
            // Show exit button when navigation is complete
            exitButton.style.display = 'block';
            
            // Create a planet info popup
            showPlanetInfoPopup(planetName);
        }
    });
    
    // Hide visit popup during navigation
    hideVisitPopup();
}

// Ship controls
const shipControls = {
    thrust: false,
    up: false,
    down: false,
    left: false,
    right: false
};

// Event Listeners
window.addEventListener('resize', () => {
    // Update sizes
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    // Update camera
    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    // Update renderer
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});

// Planet selection
document.querySelectorAll('.planet-selector li').forEach(item => {
    item.addEventListener('click', () => {
        const planetName = item.getAttribute('data-planet');
        navigateToPlanet(planetName);
    });
});

// Ship controls
document.querySelector('.control-button.thrust').addEventListener('mousedown', () => {
    shipControls.thrust = true;
});
document.querySelector('.control-button.thrust').addEventListener('mouseup', () => {
    shipControls.thrust = false;
});
document.querySelector('.control-button.up').addEventListener('mousedown', () => {
    shipControls.up = true;
});
document.querySelector('.control-button.up').addEventListener('mouseup', () => {
    shipControls.up = false;
});
document.querySelector('.control-button.down').addEventListener('mousedown', () => {
    shipControls.down = true;
});
document.querySelector('.control-button.down').addEventListener('mouseup', () => {
    shipControls.down = false;
});
document.querySelector('.control-button.left').addEventListener('mousedown', () => {
    shipControls.left = true;
});
document.querySelector('.control-button.left').addEventListener('mouseup', () => {
    shipControls.left = false;
});
document.querySelector('.control-button.right').addEventListener('mousedown', () => {
    shipControls.right = true;
});
document.querySelector('.control-button.right').addEventListener('mouseup', () => {
    shipControls.right = false;
});

// Keyboard controls
window.addEventListener('keydown', (event) => {
    switch(event.key) {
        case 'w':
        case 'ArrowUp':
            shipControls.up = true;
            break;
        case 's':
        case 'ArrowDown':
            shipControls.down = true;
            break;
        case 'a':
        case 'ArrowLeft':
            shipControls.left = true;
            break;
        case 'd':
        case 'ArrowRight':
            shipControls.right = true;
            break;
        case ' ':
            shipControls.thrust = true;
            break;
        case 'Shift':
            // Visit nearby planet when Shift is pressed
            if (nearbyPlanet) {
                navigateToPlanet(nearbyPlanet);
            }
            break;
        case '1':
            navigateToPlanet('home');
            break;
        case '2':
            navigateToPlanet('projects');
            break;
        case '3':
            navigateToPlanet('skills');
            break;
        case '4':
            navigateToPlanet('about');
            break;
        case '5':
            navigateToPlanet('contact');
            break;
    }
});

window.addEventListener('keyup', (event) => {
    switch(event.key) {
        case 'w':
        case 'ArrowUp':
            shipControls.up = false;
            break;
        case 's':
        case 'ArrowDown':
            shipControls.down = false;
            break;
        case 'a':
        case 'ArrowLeft':
            shipControls.left = false;
            break;
        case 'd':
        case 'ArrowRight':
            shipControls.right = false;
            break;
        case ' ':
            shipControls.thrust = false;
            break;
    }
});

// Animation
const clock = new THREE.Clock();
let previousTime = 0;

// Function to show the visit popup
function showVisitPopup(planetName) {
    visitPopup.textContent = `Visit ${planetName} (Press SHIFT)`;
    visitPopup.style.display = 'block';
    visitPopupVisible = true;
}

// Function to hide the visit popup
function hideVisitPopup() {
    visitPopup.style.display = 'none';
    visitPopupVisible = false;
}

// Function to check if spaceship is near a planet
function checkPlanetProximity() {
    // Don't check proximity if we're in planet view mode
    if (inPlanetView) return;
    
    let closestPlanet = null;
    let closestDistance = Infinity;
    const proximityThreshold = 20; // Distance to trigger highlight
    
    // Reset all planet materials to normal
    for (const planetName in planets) {
        const planet = planets[planetName];
        planet.material.emissive.set(0x000000);
        planet.material.emissiveIntensity = 0;
    }
    
    // Check distance to each planet
    for (const planetName in planets) {
        const planet = planets[planetName];
        const distance = spaceship.position.distanceTo(planet.position);
        
        if (distance < closestDistance) {
            closestDistance = distance;
            closestPlanet = planetName;
        }
    }
    
    // If close enough to a planet, highlight it and show popup
    if (closestDistance < proximityThreshold && !isNavigating) {
        const planet = planets[closestPlanet];
        
        // Highlight the planet
        planet.material.emissive.set(0xffffff);
        planet.material.emissiveIntensity = 0.3;
        
        // Show visit popup if not already visible for this planet
        if (nearbyPlanet !== closestPlanet || !visitPopupVisible) {
            showVisitPopup(closestPlanet);
        }
        
        nearbyPlanet = closestPlanet;
    } else {
        // Hide popup if not near any planet
        if (visitPopupVisible) {
            hideVisitPopup();
        }
        nearbyPlanet = null;
    }
}

const tick = () => {
    const elapsedTime = clock.getElapsedTime();
    const deltaTime = elapsedTime - previousTime;
    previousTime = elapsedTime;

    // Rotate planets
    homePlanet.rotation.y += 0.005;
    projectsPlanet.rotation.y += 0.003;
    skillsPlanet.rotation.y += 0.007;
    aboutPlanet.rotation.y += 0.004;
    contactPlanet.rotation.y += 0.006;

    // Rotate project planets
    if (ampleHarvestPlanet) ampleHarvestPlanet.rotation.y += 0.008;
    if (qaoaPlanet) qaoaPlanet.rotation.y += 0.007;
    if (faciesPlanet) faciesPlanet.rotation.y += 0.009;
    if (boulderPlanet) boulderPlanet.rotation.y += 0.006;
    if (momentumPlanet) momentumPlanet.rotation.y += 0.008;
    if (burgerPlanet) burgerPlanet.rotation.y += 0.007;
    if (galaxseaPlanet) galaxseaPlanet.rotation.y += 0.009;
    if (skyfarerPlanet) skyfarerPlanet.rotation.y += 0.006;

    // Rotate labels to always face camera
    if (homeLabel) homeLabel.position.copy(homePlanet.position).add(new THREE.Vector3(0, 8, 0));
    if (projectsLabel) projectsLabel.position.copy(projectsPlanet.position).add(new THREE.Vector3(0, 10, 0));
    if (skillsLabel) skillsLabel.position.copy(skillsPlanet.position).add(new THREE.Vector3(0, 7, 0));
    if (aboutLabel) aboutLabel.position.copy(aboutPlanet.position).add(new THREE.Vector3(0, 9, 0));
    if (contactLabel) contactLabel.position.copy(contactPlanet.position).add(new THREE.Vector3(0, 6, 0));

    // Update project planet labels
    if (ampleHarvestLabel) ampleHarvestLabel.position.copy(ampleHarvestPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (qaoaLabel) qaoaLabel.position.copy(qaoaPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (faciesLabel) faciesLabel.position.copy(faciesPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (boulderLabel) boulderLabel.position.copy(boulderPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (momentumLabel) momentumLabel.position.copy(momentumPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (burgerLabel) burgerLabel.position.copy(burgerPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (galaxseaLabel) galaxseaLabel.position.copy(galaxseaPlanet.position).add(new THREE.Vector3(0, 4, 0));
    if (skyfarerLabel) skyfarerLabel.position.copy(skyfarerPlanet.position).add(new THREE.Vector3(0, 4, 0));
    
    // Check if near a planet (only in travel mode)
    if (!inPlanetView) {
        checkPlanetProximity();
    }
    
    // Update spaceship light position to follow camera
    spaceshipLight.position.copy(camera.position);
    
    // Simple ship controls
    if (!isNavigating) {
        const moveSpeed = 0.3;
        const rotateSpeed = 0.04;
        
        // Handle movement with thrust - only if not in planet view
        if (shipControls.thrust && !inPlanetView) {
            // Calculate direction based on spaceship's orientation
            // Negative Z is forward for the ship (original behavior)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(spaceship.quaternion);
            
            // Calculate the potential new position
            const potentialPosition = spaceship.position.clone().add(direction.clone().multiplyScalar(moveSpeed));
            
            // Check for collisions with planets
            let collision = false;
            const shipCollisionRadius = spaceship.userData.collisionRadius || 3;
            
            for (const planetName in planets) {
                const planet = planets[planetName];
                const planetRadius = planet.geometry.parameters.radius;
                const safeDistance = planetRadius + shipCollisionRadius;
                
                // Calculate distance between potential position and planet
                const distance = potentialPosition.distanceTo(planet.position);
                
                if (distance < safeDistance) {
                    collision = true;
                    break;
                }
            }
            
            // Only move if there's no collision
            if (!collision) {
                spaceship.position.copy(potentialPosition);
            } else {
                // Optional: Add a subtle bounce effect when colliding
                const bounceDirection = new THREE.Vector3();
                for (const planetName in planets) {
                    const planet = planets[planetName];
                    const toPlanet = new THREE.Vector3().subVectors(planet.position, spaceship.position).normalize();
                    bounceDirection.sub(toPlanet.multiplyScalar(0.1));
                }
                spaceship.position.add(bounceDirection);
            }
            
            // Thruster effect
            if (thruster) {
                thruster.visible = true;
                thrusterLight.intensity = 5; // Brighter light
                thrusterParticles.visible = true;
                
                // Animate particles
                const positions = thrusterParticles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Move particles outward from the visual back
                    positions[i3 + 2] += 0.15 * Math.random();
                    
                    // Reset particles that go too far
                    if (positions[i3 + 2] > 5) {
                        positions[i3] = (Math.random() - 0.5) * 0.5;
                        positions[i3 + 1] = (Math.random() - 0.5) * 0.5;
                        positions[i3 + 2] = 2;
                    }
                }
                thrusterParticles.geometry.attributes.position.needsUpdate = true;
            }
        } else {
            if (thruster) {
                thruster.visible = false;
                thrusterLight.intensity = 0;
                thrusterParticles.visible = false;
            }
        }
        
        // Handle camera movement with thrust - only if not in planet view
        if (shipControls.thrust && !inPlanetView) {
            // Calculate direction based on spaceship's orientation
            // Negative Z is forward for the ship (original behavior)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(spaceship.quaternion);
            
            // Move camera in that direction
            camera.position.add(direction.multiplyScalar(moveSpeed));
        }
        
        // Handle rotation with mixed global/local axes - only if not in planet view
        if ((shipControls.left || shipControls.right) && !inPlanetView) {
            // Yaw: Rotate around global Y axis (vertical axis)
            const globalYAxis = new THREE.Vector3(0, 1, 0);
            const yawAmount = (shipControls.left ? rotateSpeed : 0) + (shipControls.right ? -rotateSpeed : 0);
            if (yawAmount !== 0) {
                const yawRotation = new THREE.Quaternion().setFromAxisAngle(globalYAxis, yawAmount);
                spaceship.quaternion.premultiply(yawRotation);
            }
        }
        
        if ((shipControls.up || shipControls.down) && !inPlanetView) {
            // Pitch: Rotate around the ship's local X axis (which is always horizontal)
            // First, get the ship's right vector (local X axis)
            const shipRight = new THREE.Vector3(1, 0, 0).applyQuaternion(spaceship.quaternion);
            
            // Make sure this vector is perfectly horizontal by zeroing out its Y component and renormalizing
            shipRight.y = 0;
            shipRight.normalize();
            
            // Now rotate around this horizontal axis that passes through the ship
            // Reduced sensitivity for up/down by multiplying by 0.6
            const reducedRotateSpeed = rotateSpeed * 0.6;
            const pitchAmount = (shipControls.up ? -reducedRotateSpeed : 0) + (shipControls.down ? reducedRotateSpeed : 0);
            if (pitchAmount !== 0) {
                const pitchRotation = new THREE.Quaternion().setFromAxisAngle(shipRight, pitchAmount);
                spaceship.quaternion.premultiply(pitchRotation);
            }
        }
        
        // Update camera to follow spaceship
        if (!isNavigating && !inPlanetView) {
            // Calculate camera position based on spaceship position and rotation
            const cameraOffset = new THREE.Vector3(0, 5, 15);
            cameraOffset.applyQuaternion(spaceship.quaternion);
            camera.position.copy(spaceship.position).add(cameraOffset);
            
            // Make camera look at spaceship
            controls.target.copy(spaceship.position);
        }
    }
    
    // Update controls
    controls.update();

    // Render
    renderer.render(scene, camera);

    // Call tick again on the next frame
    window.requestAnimationFrame(tick);
};

// Start animation loop
tick();

// Initialize with home planet
setTimeout(() => {
    navigateToPlanet('home');
}, 1500);
